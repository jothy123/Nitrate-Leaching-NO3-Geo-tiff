import time
start_time = time.perf_counter()

from osgeo import gdal
gdal.UseExceptions()

from pyproj import Transformer
import numpy as np
from scipy.spatial import cKDTree
import sys

# -------------------------------------------------
# Open raster helper (SAFE for normal-sized rasters)
# -------------------------------------------------
def open_raster(path):
    ds = gdal.Open(path)
    if ds is None:
        raise FileNotFoundError(f"Could not open {path}")
    band = ds.GetRasterBand(1)
    return (
        ds,
        band.ReadAsArray(),
        band.GetNoDataValue(),
        ds.GetGeoTransform(),
        ds.GetProjection()
    )

# -------------------------------------------------
# Convert XY → row/col
# -------------------------------------------------
def xy_to_rowcol(gt, arr, x, y):
    col = int((x - gt[0]) / gt[1])
    row = int((y - gt[3]) / gt[5])

    if arr is not None:
        if row < 0 or col < 0 or row >= arr.shape[0] or col >= arr.shape[1]:
            return None, None
    return row, col

# -------------------------------------------------
# Nearest valid pixel using KDTree
# -------------------------------------------------
def nearest_valid_value(arr, nodata, gt, x, y):
    rows, cols = arr.shape

    x_coords = gt[0] + (np.arange(cols) + 0.5) * gt[1]
    y_coords = gt[3] + (np.arange(rows) + 0.5) * gt[5]
    X, Y = np.meshgrid(x_coords, y_coords)

    mask = arr != nodata
    coords = np.column_stack((X[mask], Y[mask]))
    values = arr[mask]

    tree = cKDTree(coords)
    _, idx = tree.query([x, y], k=1)

    return values[idx], coords[idx]

# -------------------------------------------------
# Read a single pixel safely
# -------------------------------------------------
def read_pixel(band, row, col):
    try:
        val = band.ReadAsArray(col, row, 1, 1)
        if val is None:
            return None
        return val[0, 0]
    except RuntimeError:
        return None

# -------------------------------------------------
# Load NORMAL rasters (4326)
# -------------------------------------------------
ds_ph, arr_ph, nodata_ph, gt_ph, proj = open_raster("F:/NP/pH_CaCl/4326.tif")
ds_water, arr_water, nodata_water, gt_water, _ = open_raster("F:/NP/water_mask_whole_reprojected_EU.tif")
ds_koppen, arr_koppen, nodata_koppen, gt_koppen, _ = open_raster("F:/NP/Prototype_input_original_image-20260107T225850Z-1-001/Prototype_input_original_image/Koppen_climate/koppen_geiger_0p00833333.tif")
ds_kfac, arr_kfac, nodata_kfac, gt_kfac, _ = open_raster("F:/NP/Prototype_input_original_image-20260107T225850Z-1-001/Prototype_input_original_image/Erodibility_Kfactor/K-Factor.tif")

# -------------------------------------------------
# Load LARGE rasters (3035)
# -------------------------------------------------
def open_large_raster(path):
    ds = gdal.Open(path)
    if ds is None:
        raise FileNotFoundError(f"Could not open {path}")
    band = ds.GetRasterBand(1)
    return ds, band, band.GetNoDataValue(), ds.GetGeoTransform(), ds.GetProjection()

ds_slope, band_slope, nodata_slope, gt_slope, proj_slope = open_large_raster("F:/NP/Prototype_input_original_image-20260107T225850Z-1-001/Prototype_input_original_image/slope/eudem_slop_3035_europe.tif")
ds_clay, band_clay, nodata_clay, gt_clay, proj_clay = open_large_raster("F:/NP/Clay_Extra/Clay.tif")
ds_cn, band_cn, nodata_cn, gt_cn, proj_cn = open_large_raster("F:/NP/CN/CN.tif")
ds_bulk, band_bulk, nodata_bulk, gt_bulk, proj_bulk = open_large_raster("F:/NP/BulkDensity_Extra/Bulk_density.tif")

# -------------------------------------------------
# Input coordinate (WGS84)
# -------------------------------------------------
lat = float(input("Enter latitude: "))
lon = float(input("Enter longitude: "))

transformer_main = Transformer.from_crs("EPSG:4326", proj, always_xy=True)
x, y = transformer_main.transform(lon, lat)

# -------------------------------------------------
# WATER CHECK
# -------------------------------------------------
row_w, col_w = xy_to_rowcol(gt_water, arr_water, x, y)

if row_w is None:
    print("Outside water mask.")
    sys.exit()

if arr_water[row_w, col_w] == 1:
    print("Location in water.")
    sys.exit()

print("Location on land")

# -------------------------------------------------
# pH, Köppen, K-factor
# -------------------------------------------------
row_ph, col_ph = xy_to_rowcol(gt_ph, arr_ph, x, y)
row_k, col_k = xy_to_rowcol(gt_koppen, arr_koppen, x, y)
row_kf, col_kf = xy_to_rowcol(gt_kfac, arr_kfac, x, y)

ph_value = float(arr_ph[row_ph, col_ph]) if row_ph is not None else None
koppen_value = float(arr_koppen[row_k, col_k]) if row_k is not None else None
kfactor_value = float(arr_kfac[row_kf, col_kf]) if row_kf is not None else None

# -------------------------------------------------
# Transformer for 3035 rasters
# -------------------------------------------------
transformer_3035 = Transformer.from_crs("EPSG:4326", proj_slope, always_xy=True)
x_3035, y_3035 = transformer_3035.transform(lon, lat)

# -------------------------------------------------
# Generic nearest search for large rasters
# -------------------------------------------------
def get_value_large(band, gt, nodata, x, y):
    row, col = xy_to_rowcol(gt, None, x, y)
    value = read_pixel(band, row, col)
    used_nearest = False

    if value in (None, nodata):
        for radius in range(1, 11):
            for dr in range(-radius, radius + 1):
                for dc in range(-radius, radius + 1):
                    r = row + dr
                    c = col + dc
                    if r < 0 or c < 0:
                        continue
                    val = read_pixel(band, r, c)
                    if val not in (None, nodata):
                        return val, True
    return value, used_nearest

# -------------------------------------------------
# Extract 3035 variables
# -------------------------------------------------
slope_value, used_nearest_slope = get_value_large(band_slope, gt_slope, nodata_slope, x_3035, y_3035)
clay_value, used_nearest_clay = get_value_large(band_clay, gt_clay, nodata_clay, x_3035, y_3035)
cn_value, used_nearest_cn = get_value_large(band_cn, gt_cn, nodata_cn, x_3035, y_3035)
bulk_value, used_nearest_bulk = get_value_large(band_bulk, gt_bulk, nodata_bulk, x_3035, y_3035)

# -------------------------------------------------
# Output
# -------------------------------------------------
print("\nFinal result:")
print(f"pH: {ph_value}")
print(f"Köppen: {koppen_value}")
print(f"K-factor: {kfactor_value}")
print(f"Slope: {slope_value}")
print(f"Clay: {clay_value}")
print(f"Curve Number: {cn_value}")
print(f"Bulk density: {bulk_value}")

end_time = time.perf_counter()
print(f"\nElapsed time: {end_time - start_time:.1f} seconds")

